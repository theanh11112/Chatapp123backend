// services/e2eeAutomation.js - HO√ÄN CH·ªàNH
const crypto = require("crypto");
const User = require("../models/user");
const Room = require("../models/room");
const Message = require("../models/message");

console.log("ü§ñ [e2eeAutomation] Service loaded successfully");

class E2EEAutomationService {
  constructor() {
    this.autoKeyRotationInterval = 24 * 60 * 60 * 1000; // 24 gi·ªù
    this.keyRotationTimers = new Map();
    this.init();
  }

  /**
   * Kh·ªüi t·∫°o service
   */
  async init() {
    console.log("ü§ñ [e2eeAutomation] Initializing E2EE automation service");

    // T·ª± ƒë·ªông enable E2EE cho t·∫•t c·∫£ users khi kh·ªüi ƒë·ªông
    await this.autoEnableE2EEForAllUsers();

    // B·∫Øt ƒë·∫ßu key rotation schedule
    this.startKeyRotationSchedule();

    console.log("‚úÖ [e2eeAutomation] Service initialized successfully");
  }

  /**
   * T·ª± ƒë·ªông enable E2EE cho t·∫•t c·∫£ users
   */
  async autoEnableE2EEForAllUsers() {
    try {
      console.log("ü§ñ [e2eeAutomation] Auto-enabling E2EE for all users...");

      const users = await User.find({ e2eeEnabled: { $ne: true } });

      for (const user of users) {
        try {
          await this.autoGenerateKeysForUser(user.keycloakId);
          console.log(`‚úÖ Auto-enabled E2EE for user: ${user.username}`);
        } catch (error) {
          console.error(
            `‚ùå Failed to auto-enable E2EE for ${user.username}:`,
            error.message
          );
        }
      }

      console.log(`‚úÖ Auto-enabled E2EE for ${users.length} users`);
    } catch (error) {
      console.error("‚ùå [autoEnableE2EEForAllUsers] Error:", error);
    }
  }

  /**
   * T·ª± ƒë·ªông generate keys cho user
   */
  async autoGenerateKeysForUser(keycloakId) {
    try {
      console.log(
        `ü§ñ [autoGenerateKeysForUser] Generating keys for user: ${keycloakId}`
      );

      const user = await User.findOne({ keycloakId });
      if (!user) {
        throw new Error("User not found");
      }

      // T·∫°o key pair t·ª± ƒë·ªông
      const keyPair = this.generateKeyPairAutomatically();

      // Th√™m key v√†o user
      const newKey = {
        publicKey: keyPair.publicKey,
        keyType: "ecdh-p256",
        fingerprint: this.calculateKeyFingerprint(keyPair.publicKey),
        createdAt: new Date(),
        isActive: true,
        isAutoGenerated: true,
        autoGeneratedAt: new Date(),
      };

      // ƒê√°nh d·∫•u t·∫•t c·∫£ keys c≈© l√† kh√¥ng active
      if (user.e2eeKeys && user.e2eeKeys.length > 0) {
        user.e2eeKeys.forEach((key) => {
          key.isActive = false;
        });
      }

      // Th√™m key m·ªõi
      user.e2eeKeys = user.e2eeKeys || [];
      user.e2eeKeys.push(newKey);
      user.currentKeyId = newKey.fingerprint;
      user.e2eeEnabled = true;
      user.autoE2EEEnabled = true;
      user.lastKeyRotation = new Date();

      await user.save();

      // L∆∞u private key t·∫°m th·ªùi (trong th·ª±c t·∫ø c·∫ßn l∆∞u an to√†n)
      await this.storeTemporaryPrivateKey(
        keycloakId,
        keyPair.privateKey,
        newKey.fingerprint
      );

      console.log(
        `‚úÖ Auto-generated keys for user: ${user.username}, fingerprint: ${newKey.fingerprint}`
      );

      return {
        success: true,
        fingerprint: newKey.fingerprint,
        keyType: newKey.keyType,
        publicKey: newKey.publicKey,
      };
    } catch (error) {
      console.error(
        `‚ùå [autoGenerateKeysForUser] Error for ${keycloakId}:`,
        error
      );
      throw error;
    }
  }

  /**
   * T·∫°o key pair t·ª± ƒë·ªông
   */
  generateKeyPairAutomatically() {
    const ecdh = crypto.createECDH("prime256v1");
    ecdh.generateKeys();

    return {
      publicKey: ecdh.getPublicKey("base64"),
      privateKey: ecdh.getPrivateKey("base64"),
      algorithm: "ECDH",
      curve: "prime256v1",
    };
  }

  /**
   * T√≠nh fingerprint
   */
  calculateKeyFingerprint(publicKey) {
    return crypto
      .createHash("sha256")
      .update(publicKey)
      .digest("hex")
      .substring(0, 8)
      .toUpperCase();
  }

  /**
   * L∆∞u private key t·∫°m th·ªùi (DEMO ONLY - kh√¥ng d√πng production)
   */
  async storeTemporaryPrivateKey(userId, privateKey, fingerprint) {
    // Trong th·ª±c t·∫ø, private key n√™n ƒë∆∞·ª£c l∆∞u ·ªü client-side ho·∫∑c HSM
    // ƒê√¢y ch·ªâ l√† demo ƒë·ªÉ minh h·ªça
    const tempStorage = {
      userId,
      fingerprint,
      privateKey,
      storedAt: new Date(),
      expiresAt: new Date(Date.now() + 5 * 60 * 1000), // 5 ph√∫t
    };

    console.log(`‚ö†Ô∏è TEMP private key stored for ${userId} (expires in 5 mins)`);
    // Trong th·ª±c t·∫ø: g·ª≠i private key qua secure channel ƒë·∫øn client
  }

  /**
   * T·ª± ƒë·ªông rotate keys theo l·ªãch
   */
  startKeyRotationSchedule() {
    console.log("üîÑ [e2eeAutomation] Starting automatic key rotation schedule");

    // Rotate keys m·ªói 24 gi·ªù
    setInterval(async () => {
      try {
        await this.rotateKeysForAllUsers();
      } catch (error) {
        console.error("‚ùå [Key Rotation Schedule] Error:", error);
      }
    }, this.autoKeyRotationInterval);
  }

  /**
   * Rotate keys cho t·∫•t c·∫£ users
   */
  async rotateKeysForAllUsers() {
    try {
      console.log("üîÑ [rotateKeysForAllUsers] Starting key rotation...");

      const users = await User.find({
        e2eeEnabled: true,
        autoE2EEEnabled: true,
      });

      let rotatedCount = 0;
      let failedCount = 0;

      for (const user of users) {
        try {
          // Ki·ªÉm tra n·∫øu ƒë√£ rotate trong 24 gi·ªù qua
          if (
            user.lastKeyRotation &&
            Date.now() - user.lastKeyRotation.getTime() <
              this.autoKeyRotationInterval
          ) {
            continue;
          }

          await this.rotateUserKey(user.keycloakId);
          rotatedCount++;
        } catch (error) {
          console.error(
            `‚ùå Failed to rotate key for ${user.username}:`,
            error.message
          );
          failedCount++;
        }
      }

      console.log(
        `‚úÖ Key rotation completed: ${rotatedCount} rotated, ${failedCount} failed`
      );
    } catch (error) {
      console.error("‚ùå [rotateKeysForAllUsers] Error:", error);
    }
  }

  /**
   * Rotate key cho m·ªôt user c·ª• th·ªÉ
   */
  async rotateUserKey(keycloakId) {
    try {
      console.log(`üîÑ [rotateUserKey] Rotating key for user: ${keycloakId}`);

      const user = await User.findOne({ keycloakId });
      if (!user || !user.e2eeEnabled) {
        throw new Error("User not found or E2EE not enabled");
      }

      // T·∫°o key m·ªõi
      const keyPair = this.generateKeyPairAutomatically();

      // Revoke key c≈©
      const currentKey = user.e2eeKeys.find(
        (k) => k.fingerprint === user.currentKeyId
      );
      if (currentKey) {
        currentKey.isActive = false;
        currentKey.isRevoked = true;
        currentKey.revokedAt = new Date();
        currentKey.revokedReason = "automatic_rotation";
      }

      // Th√™m key m·ªõi
      const newKey = {
        publicKey: keyPair.publicKey,
        keyType: "ecdh-p256",
        fingerprint: this.calculateKeyFingerprint(keyPair.publicKey),
        createdAt: new Date(),
        isActive: true,
        isAutoGenerated: true,
        autoGeneratedAt: new Date(),
        rotationNumber: (user.e2eeKeys?.length || 0) + 1,
      };

      user.e2eeKeys.push(newKey);
      user.currentKeyId = newKey.fingerprint;
      user.lastKeyRotation = new Date();

      await user.save();

      // L∆∞u private key t·∫°m th·ªùi
      await this.storeTemporaryPrivateKey(
        keycloakId,
        keyPair.privateKey,
        newKey.fingerprint
      );

      // Th√¥ng b√°o cho friends v·ªÅ key m·ªõi
      await this.notifyFriendsAboutKeyRotation(user);

      console.log(
        `‚úÖ Key rotated for user: ${user.username}, new fingerprint: ${newKey.fingerprint}`
      );

      return {
        success: true,
        oldFingerprint: currentKey?.fingerprint,
        newFingerprint: newKey.fingerprint,
        rotationTime: new Date(),
      };
    } catch (error) {
      console.error(`‚ùå [rotateUserKey] Error for ${keycloakId}:`, error);
      throw error;
    }
  }

  /**
   * Th√¥ng b√°o cho friends v·ªÅ key rotation
   */
  async notifyFriendsAboutKeyRotation(user) {
    try {
      if (!user.friends || user.friends.length === 0) {
        return;
      }

      const currentKey = user.e2eeKeys.find(
        (k) => k.fingerprint === user.currentKeyId
      );

      // Trong th·ª±c t·∫ø s·∫Ω g·ª≠i socket event
      console.log(
        `üì¢ Notifying ${user.friends.length} friends about key rotation for ${user.username}`
      );

      // Log cho debug
      user.friends.forEach((friendId) => {
        console.log(
          `   ‚Üí Friend: ${friendId}, New key: ${currentKey.fingerprint}`
        );
      });
    } catch (error) {
      console.error(`‚ùå [notifyFriendsAboutKeyRotation] Error:`, error);
    }
  }

  /**
   * T·ª± ƒë·ªông thi·∫øt l·∫≠p E2EE cho room m·ªõi
   */
  async autoSetupE2EEForRoom(roomId, creatorId) {
    try {
      console.log(
        `ü§ñ [autoSetupE2EEForRoom] Setting up E2EE for room: ${roomId}`
      );

      const room = await Room.findById(roomId);
      if (!room) {
        throw new Error("Room not found");
      }

      // Enable E2EE cho room
      room.e2eeEnabled = true;
      room.e2eeAutoSetup = true;
      room.e2eeSetupBy = creatorId;
      room.e2eeSetupAt = new Date();

      // ƒê·∫£m b·∫£o t·∫•t c·∫£ members c√≥ E2EE enabled
      for (const memberId of room.members) {
        try {
          const member = await User.findOne({ keycloakId: memberId });
          if (member && !member.e2eeEnabled) {
            await this.autoGenerateKeysForUser(memberId);
            console.log(
              `‚úÖ Auto-enabled E2EE for room member: ${member.username}`
            );
          }
        } catch (error) {
          console.error(
            `‚ùå Failed to auto-enable E2EE for member ${memberId}:`,
            error.message
          );
        }
      }

      await room.save();

      console.log(`‚úÖ Auto-setup E2EE for room: ${room.name}`);

      return {
        success: true,
        roomId: room._id,
        roomName: room.name,
        e2eeEnabled: true,
        membersWithE2EE: room.members.length,
      };
    } catch (error) {
      console.error(
        `‚ùå [autoSetupE2EEForRoom] Error for room ${roomId}:`,
        error
      );
      throw error;
    }
  }

  /**
   * T·ª± ƒë·ªông exchange keys gi·ªØa hai users
   */
  async autoExchangeKeys(user1Id, user2Id) {
    try {
      console.log(
        `ü§ù [autoExchangeKeys] Auto exchanging keys between ${user1Id} and ${user2Id}`
      );

      const [user1, user2] = await Promise.all([
        User.findOne({ keycloakId: user1Id }),
        User.findOne({ keycloakId: user2Id }),
      ]);

      if (!user1 || !user2) {
        throw new Error("One or both users not found");
      }

      // ƒê·∫£m b·∫£o c·∫£ hai ƒë·ªÅu c√≥ E2EE enabled
      if (!user1.e2eeEnabled) {
        await this.autoGenerateKeysForUser(user1Id);
      }
      if (!user2.e2eeEnabled) {
        await this.autoGenerateKeysForUser(user2Id);
      }

      // L·∫•y public keys
      const user1Key = user1.e2eeKeys.find(
        (k) => k.fingerprint === user1.currentKeyId
      );
      const user2Key = user2.e2eeKeys.find(
        (k) => k.fingerprint === user2.currentKeyId
      );

      if (!user1Key || !user2Key) {
        throw new Error("One or both users don't have active keys");
      }

      // T·∫°o exchange record (trong th·ª±c t·∫ø c√≥ th·ªÉ l∆∞u v√†o database)
      const exchangeId = this.generateExchangeId(user1Id, user2Id);

      const exchangeRecord = {
        exchangeId,
        user1: user1Id,
        user2: user2Id,
        user1Key: user1Key.fingerprint,
        user2Key: user2Key.fingerprint,
        exchangedAt: new Date(),
        status: "completed",
        isAutoExchange: true,
      };

      console.log(`‚úÖ Auto key exchange completed: ${exchangeId}`);

      return {
        success: true,
        exchangeId,
        user1: {
          id: user1Id,
          keyFingerprint: user1Key.fingerprint,
        },
        user2: {
          id: user2Id,
          keyFingerprint: user2Key.fingerprint,
        },
        exchangedAt: new Date(),
      };
    } catch (error) {
      console.error(`‚ùå [autoExchangeKeys] Error:`, error);
      throw error;
    }
  }

  /**
   * T·∫°o exchange ID
   */
  generateExchangeId(user1Id, user2Id) {
    const ids = [user1Id, user2Id].sort();
    return crypto
      .createHash("md5")
      .update(ids.join("|"))
      .digest("hex")
      .substring(0, 12)
      .toUpperCase();
  }

  /**
   * T·ª± ƒë·ªông m√£ h√≥a tin nh·∫Øn
   */
  async autoEncryptMessage(senderId, roomId, plaintext) {
    try {
      console.log(
        `üîê [autoEncryptMessage] Auto encrypting message for room: ${roomId}`
      );

      const room = await Room.findById(roomId);
      if (!room || !room.e2eeEnabled) {
        throw new Error("Room not found or E2EE not enabled");
      }

      // L·∫•y sender's current key
      const sender = await User.findOne({ keycloakId: senderId });
      if (!sender || !sender.e2eeEnabled) {
        throw new Error("Sender not found or E2EE not enabled");
      }

      const senderKey = sender.e2eeKeys.find(
        (k) => k.fingerprint === sender.currentKeyId
      );
      if (!senderKey) {
        throw new Error("Sender doesn't have active key");
      }

      // T·∫°o encryption key ng·∫´u nhi√™n (trong th·ª±c t·∫ø s·∫Ω d√πng shared secret)
      const encryptionKey = crypto.randomBytes(32); // 256-bit key
      const iv = crypto.randomBytes(12); // 96-bit IV cho AES-GCM

      // M√£ h√≥a tin nh·∫Øn
      const cipher = crypto.createCipheriv("aes-256-gcm", encryptionKey, iv);
      let encrypted = cipher.update(plaintext, "utf8", "base64");
      encrypted += cipher.final("base64");
      const authTag = cipher.getAuthTag();

      // T·∫°o encrypted message object
      const encryptedMessage = {
        ciphertext: encrypted,
        iv: iv.toString("base64"),
        keyId: senderKey.fingerprint,
        algorithm: "AES-GCM-256",
        authTag: authTag.toString("base64"),
        encryptedAt: new Date(),
        senderKeyFingerprint: senderKey.fingerprint,
        isAutoEncrypted: true,
      };

      console.log(
        `‚úÖ Message auto-encrypted, ciphertext length: ${encrypted.length}`
      );

      return {
        success: true,
        encryptedData: encryptedMessage,
        originalLength: plaintext.length,
        encryptedLength: encrypted.length,
      };
    } catch (error) {
      console.error(`‚ùå [autoEncryptMessage] Error:`, error);
      throw error;
    }
  }

  /**
   * T·ª± ƒë·ªông ƒë·ªìng b·ªô keys cho t·∫•t c·∫£ users
   */
  async syncAllUsersKeys() {
    try {
      console.log("üîÑ [syncAllUsersKeys] Syncing keys for all users...");

      const users = await User.find({ e2eeEnabled: true });

      const syncReport = {
        totalUsers: users.length,
        synced: 0,
        failed: 0,
        details: [],
      };

      for (const user of users) {
        try {
          // Ki·ªÉm tra v√† fix keys n·∫øu c·∫ßn
          await this.validateAndFixUserKeys(user);
          syncReport.synced++;
          syncReport.details.push({
            userId: user.keycloakId,
            username: user.username,
            status: "synced",
            activeKey: user.currentKeyId,
          });
        } catch (error) {
          syncReport.failed++;
          syncReport.details.push({
            userId: user.keycloakId,
            username: user.username,
            status: "failed",
            error: error.message,
          });
        }
      }

      console.log(
        `‚úÖ Keys sync completed: ${syncReport.synced} synced, ${syncReport.failed} failed`
      );

      return syncReport;
    } catch (error) {
      console.error("‚ùå [syncAllUsersKeys] Error:", error);
      throw error;
    }
  }

  /**
   * Validate v√† fix user keys n·∫øu c·∫ßn
   */
  async validateAndFixUserKeys(user) {
    const issues = [];

    // Ki·ªÉm tra c√≥ active key kh√¥ng
    const activeKey = user.e2eeKeys?.find((k) => k.isActive);
    if (!activeKey) {
      issues.push("No active key found");
      // T·ª± ƒë·ªông t·∫°o key m·ªõi
      await this.autoGenerateKeysForUser(user.keycloakId);
    }

    // Ki·ªÉm tra currentKeyId c√≥ match v·ªõi active key kh√¥ng
    if (
      user.currentKeyId &&
      activeKey &&
      user.currentKeyId !== activeKey.fingerprint
    ) {
      issues.push("currentKeyId doesn't match active key");
      user.currentKeyId = activeKey.fingerprint;
    }

    // Ki·ªÉm tra c√≥ nhi·ªÅu h∆°n 1 active key kh√¥ng
    const activeKeys = user.e2eeKeys?.filter((k) => k.isActive) || [];
    if (activeKeys.length > 1) {
      issues.push(`Multiple active keys found: ${activeKeys.length}`);
      // Ch·ªâ gi·ªØ l·∫°i key m·ªõi nh·∫•t
      const latestActiveKey = activeKeys.sort(
        (a, b) => b.createdAt - a.createdAt
      )[0];
      activeKeys.forEach((key) => {
        if (key.fingerprint !== latestActiveKey.fingerprint) {
          key.isActive = false;
        }
      });
    }

    if (issues.length > 0) {
      console.log(`‚ö†Ô∏è Fixed issues for ${user.username}:`, issues);
      await user.save();
    }

    return {
      hadIssues: issues.length > 0,
      issues,
      fixed: issues.length,
    };
  }

  /**
   * Get automation status
   */
  async getAutomationStatus() {
    const totalUsers = await User.countDocuments();
    const e2eeEnabledUsers = await User.countDocuments({ e2eeEnabled: true });
    const autoEnabledUsers = await User.countDocuments({
      autoE2EEEnabled: true,
    });

    const roomsWithE2EE = await Room.countDocuments({ e2eeEnabled: true });
    const totalRooms = await Room.countDocuments();

    const lastSync = await User.findOne({ e2eeEnabled: true })
      .sort({ lastKeyRotation: -1 })
      .select("lastKeyRotation");

    return {
      automation: {
        serviceRunning: true,
        startedAt: new Date(),
        uptime: process.uptime(),
      },
      users: {
        total: totalUsers,
        e2eeEnabled: e2eeEnabledUsers,
        autoEnabled: autoEnabledUsers,
        percentage:
          totalUsers > 0
            ? ((e2eeEnabledUsers / totalUsers) * 100).toFixed(1) + "%"
            : "0%",
      },
      rooms: {
        total: totalRooms,
        e2eeEnabled: roomsWithE2EE,
        percentage:
          totalRooms > 0
            ? ((roomsWithE2EE / totalRooms) * 100).toFixed(1) + "%"
            : "0%",
      },
      keyRotation: {
        interval: this.autoKeyRotationInterval,
        lastRotation: lastSync?.lastKeyRotation || null,
      },
    };
  }
}

// T·∫°o singleton instance
const e2eeAutomationService = new E2EEAutomationService();

module.exports = e2eeAutomationService;
